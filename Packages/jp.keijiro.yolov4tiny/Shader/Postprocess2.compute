// Second stage postprocessing (overlap removal)

#pragma kernel Postprocess2

#include "Common.hlsl"

// Input
StructuredBuffer<Detection> Input;
RWStructuredBuffer<uint> InputCount;
int isSoftNMS;
float Sigma;
float ScoreThreshold;
float IouThreshold;

// Output
AppendStructuredBuffer<Detection> Output;

// Local array for data cache
groupshared Detection _entries[MAX_DETECTION];

[numthreads(1, 1, 1)]
void Postprocess2(uint3 id : SV_DispatchThreadID)
{
    // Initialize data cache arrays
    uint entry_count = min(MAX_DETECTION, InputCount.IncrementCounter()); 
    if (entry_count == 0) return;

    // Fit to inference model
    uint NUM_CLASSES = 20;

    // Apply for each class
    for (uint c = 0; c < NUM_CLASSES; c++)
    {
        // Separate detections by class
        uint count = 0;

        for (uint i = 0; i < entry_count; i++)
        {
            Detection entry = Input[i];
            if (entry.classIndex != c) continue;

            // Store the detection in the cache array
            _entries[count] = entry;
            count++;
        }

        if (count == 0) continue;

        // Sort detections by score
        for (uint i = 0; i < count - 1; i++)
        {
            for (uint j = i + 1; j < count; j++)
            {
                if (_entries[i].score < _entries[j].score)
                {
                    Detection temp = _entries[i];
                    _entries[i] = _entries[j];
                    _entries[j] = temp;
                }
            }
        }

        // Apply Soft NMS or regular NMS
        for (uint i = 0; i < count - 1; i++)
        {
            for (uint j = i + 1; j < count; j++)
            {
                float iou = CalculateIOU(_entries[i], _entries[j]);

                if (isSoftNMS)
                {
                    // Soft NMS
                    if (iou > 0)
                    {
                        float weight = exp(-(iou * iou) / Sigma);
                        _entries[j].score *= weight;
                    }
                }
                else
                {
                    // Regular NMS
                    if (iou > IouThreshold)
                    {
                        _entries[j].score = 0.0;
                    }
                }
            }
        }

        // Output aggregation
        for (uint i = 0; i < count; i++)
        {
            Detection entry = _entries[i];

            if ((isSoftNMS && entry.score > ScoreThreshold) || (!isSoftNMS && entry.score > 0))
            {
                Output.Append(entry);
            }
        }

    }
}
